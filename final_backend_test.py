#!/usr/bin/env python3
"""
Final Comprehensive Backend Testing for Iranian Crypto Exchange
Testing ALL endpoints specified in the review request with admin user
"""

import asyncio
import httpx
import json
from datetime import datetime

# Configuration
BACKEND_URL = "https://cryptotradera.preview.emergentagent.com/api"
ADMIN_EMAIL = "admin"
ADMIN_PASSWORD = "istari118"

class FinalBackendTester:
    def __init__(self):
        self.client = httpx.AsyncClient(timeout=30.0)
        self.admin_token = None
        self.test_user_token = None
        self.test_results = []
        
    async def test_admin_login(self):
        """Test admin login - POST /api/auth/login"""
        print("üîë Testing Admin Login (admin/istari118)...")
        
        try:
            response = await self.client.post(f"{BACKEND_URL}/auth/login", json={
                "email": ADMIN_EMAIL,
                "password": ADMIN_PASSWORD
            })
            
            if response.status_code == 200:
                data = response.json()
                self.admin_token = data["access_token"]
                admin_info = data["user"]
                
                print(f"‚úÖ Admin login successful")
                print(f"üìä Admin Name: {admin_info.get('full_name', 'Admin')}")
                print(f"üìä KYC Level: {admin_info.get('kyc_level', 'N/A')}")
                print(f"üìä Balance: {admin_info.get('wallet_balance_tmn', 0):,.0f} TMN")
                print(f"üìä Is Admin: {admin_info.get('is_admin', False)}")
                
                self.test_results.append({"endpoint": "POST /api/auth/login", "status": "‚úÖ PASS", "details": "Admin login working with JWT token"})
                return True
            else:
                print(f"‚ùå Admin login failed: {response.status_code}")
                self.test_results.append({"endpoint": "POST /api/auth/login", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                return False
                
        except Exception as e:
            print(f"‚ùå Admin login error: {str(e)}")
            self.test_results.append({"endpoint": "POST /api/auth/login", "status": "‚ùå ERROR", "details": str(e)})
            return False

    async def test_user_registration(self):
        """Test user registration - POST /api/auth/register"""
        print("\nüë§ Testing User Registration...")
        
        try:
            timestamp = int(datetime.now().timestamp())
            test_email = f"test_reg_{timestamp}@example.com"
            test_phone = f"0912345{timestamp % 10000:04d}"
            
            response = await self.client.post(f"{BACKEND_URL}/auth/register", json={
                "first_name": "⁄©ÿßÿ±ÿ®ÿ±",
                "last_name": "ÿ™ÿ≥ÿ™",
                "email": test_email,
                "phone": test_phone,
                "password": "test123456"
            })
            
            if response.status_code == 200:
                data = response.json()
                user_info = data["user"]
                
                print(f"‚úÖ User registration successful")
                print(f"üìä User Name: {user_info.get('full_name', 'N/A')}")
                print(f"üìä Email: {user_info.get('email', 'N/A')}")
                print(f"üìä Is Admin: {user_info.get('is_admin', False)}")
                
                # Verify is_admin=False for new users
                if not user_info.get('is_admin', True):
                    print("‚úÖ Confirmed: New users are not admin by default")
                    self.test_results.append({"endpoint": "POST /api/auth/register", "status": "‚úÖ PASS", "details": "Registration working, is_admin=False for new users"})
                else:
                    print("‚ö†Ô∏è  Warning: New user has admin privileges")
                    self.test_results.append({"endpoint": "POST /api/auth/register", "status": "‚ö†Ô∏è  PARTIAL", "details": "Registration working but new user has admin privileges"})
                
                return True
            else:
                print(f"‚ùå User registration failed: {response.status_code}")
                self.test_results.append({"endpoint": "POST /api/auth/register", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                return False
                
        except Exception as e:
            print(f"‚ùå User registration error: {str(e)}")
            self.test_results.append({"endpoint": "POST /api/auth/register", "status": "‚ùå ERROR", "details": str(e)})
            return False

    async def test_get_current_user(self):
        """Test get current user - GET /api/auth/me"""
        print("\nüë§ Testing Get Current User...")
        
        if not self.admin_token:
            print("‚ùå No admin token available")
            self.test_results.append({"endpoint": "GET /api/auth/me", "status": "‚ùå FAIL", "details": "No admin token"})
            return
        
        try:
            headers = {"Authorization": f"Bearer {self.admin_token}"}
            response = await self.client.get(f"{BACKEND_URL}/auth/me", headers=headers)
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Get current user working")
                print(f"üìä User Data Retrieved: {len(data)} fields")
                
                # Verify JWT token and user data response
                required_fields = ['id', 'email', 'full_name', 'kyc_level', 'is_admin']
                missing_fields = [field for field in required_fields if field not in data]
                
                if not missing_fields:
                    print("‚úÖ JWT token verification and user data response complete")
                    self.test_results.append({"endpoint": "GET /api/auth/me", "status": "‚úÖ PASS", "details": "Authenticated user data retrieval working"})
                else:
                    print(f"‚ö†Ô∏è  Missing fields: {missing_fields}")
                    self.test_results.append({"endpoint": "GET /api/auth/me", "status": "‚ö†Ô∏è  PARTIAL", "details": f"Missing fields: {missing_fields}"})
            else:
                print(f"‚ùå Get current user failed: {response.status_code}")
                self.test_results.append({"endpoint": "GET /api/auth/me", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                
        except Exception as e:
            print(f"‚ùå Get current user error: {str(e)}")
            self.test_results.append({"endpoint": "GET /api/auth/me", "status": "‚ùå ERROR", "details": str(e)})

    async def test_crypto_prices(self):
        """Test get crypto prices - GET /api/crypto/prices"""
        print("\nüí∞ Testing Get Crypto Prices...")
        
        try:
            response = await self.client.get(f"{BACKEND_URL}/crypto/prices")
            
            if response.status_code == 200:
                data = response.json()
                
                if data.get('success') and 'data' in data:
                    prices = data['data']
                    crypto_count = len(prices)
                    
                    print(f"‚úÖ Crypto prices working")
                    print(f"üìä Cryptocurrencies: {crypto_count}")
                    
                    # Verify returns 15+ cryptocurrencies with TMN prices
                    if crypto_count >= 15:
                        print("‚úÖ Returns 15+ cryptocurrencies as required")
                        
                        # Check TMN prices
                        tmn_prices_found = 0
                        for coin_id, coin_data in prices.items():
                            if 'price_tmn' in coin_data and coin_data['price_tmn'] > 0:
                                tmn_prices_found += 1
                        
                        print(f"üìä Coins with TMN prices: {tmn_prices_found}/{crypto_count}")
                        
                        if tmn_prices_found >= 15:
                            print("‚úÖ TMN prices available for cryptocurrencies")
                            self.test_results.append({"endpoint": "GET /api/crypto/prices", "status": "‚úÖ PASS", "details": f"{crypto_count} cryptocurrencies with TMN prices"})
                        else:
                            self.test_results.append({"endpoint": "GET /api/crypto/prices", "status": "‚ö†Ô∏è  PARTIAL", "details": f"Only {tmn_prices_found} coins have TMN prices"})
                    else:
                        print(f"‚ö†Ô∏è  Only {crypto_count} cryptocurrencies (expected 15+)")
                        self.test_results.append({"endpoint": "GET /api/crypto/prices", "status": "‚ö†Ô∏è  PARTIAL", "details": f"Only {crypto_count} cryptocurrencies"})
                else:
                    print("‚ùå Invalid response format")
                    self.test_results.append({"endpoint": "GET /api/crypto/prices", "status": "‚ùå FAIL", "details": "Invalid response format"})
            else:
                print(f"‚ùå Crypto prices failed: {response.status_code}")
                self.test_results.append({"endpoint": "GET /api/crypto/prices", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                
        except Exception as e:
            print(f"‚ùå Crypto prices error: {str(e)}")
            self.test_results.append({"endpoint": "GET /api/crypto/prices", "status": "‚ùå ERROR", "details": str(e)})

    async def test_create_buy_order(self):
        """Test create buy order - POST /api/trading/order"""
        print("\nüõí Testing Create Buy Order...")
        
        if not self.admin_token:
            print("‚ùå No admin token available")
            self.test_results.append({"endpoint": "POST /api/trading/order", "status": "‚ùå FAIL", "details": "No admin token"})
            return None
        
        try:
            # First add a wallet address
            await self.add_wallet_address()
            
            headers = {"Authorization": f"Bearer {self.admin_token}"}
            order_data = {
                "order_type": "buy",
                "coin_symbol": "USDT",
                "coin_id": "tether",
                "amount_tmn": 500000  # 500K TMN
            }
            
            response = await self.client.post(f"{BACKEND_URL}/trading/order", headers=headers, json=order_data)
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Buy order created successfully")
                print(f"üìä Order ID: {data.get('id', 'N/A')[:8]}...")
                print(f"üìä Amount: {data.get('amount_tmn', 0):,.0f} TMN")
                print(f"üìä Status: {data.get('status', 'N/A')}")
                
                # Verify order creation and balance deduction
                if data.get('status') == 'pending':
                    print("‚úÖ Order creation and status tracking working")
                    self.test_results.append({"endpoint": "POST /api/trading/order", "status": "‚úÖ PASS", "details": "Buy order creation working with KYC Level 2 user"})
                    return data.get('id')
                else:
                    print(f"‚ö†Ô∏è  Unexpected order status: {data.get('status')}")
                    self.test_results.append({"endpoint": "POST /api/trading/order", "status": "‚ö†Ô∏è  PARTIAL", "details": f"Order created but status is {data.get('status')}"})
                    return data.get('id')
            else:
                print(f"‚ùå Buy order creation failed: {response.status_code} - {response.text}")
                self.test_results.append({"endpoint": "POST /api/trading/order", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                return None
                
        except Exception as e:
            print(f"‚ùå Buy order creation error: {str(e)}")
            self.test_results.append({"endpoint": "POST /api/trading/order", "status": "‚ùå ERROR", "details": str(e)})
            return None

    async def add_wallet_address(self):
        """Add wallet address for testing"""
        try:
            headers = {"Authorization": f"Bearer {self.admin_token}"}
            wallet_data = {
                "symbol": "USDT",
                "address": "0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b1",
                "label": "Test USDT Wallet"
            }
            
            response = await self.client.post(f"{BACKEND_URL}/user/wallet-addresses", headers=headers, json=wallet_data)
            
            if response.status_code in [200, 201]:
                print("‚úÖ Wallet address added")
            elif response.status_code == 400 and "ŸÇÿ®ŸÑÿßŸã ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØŸá" in response.text:
                print("‚úÖ Wallet address already exists")
            else:
                print(f"‚ö†Ô∏è  Wallet address issue: {response.status_code}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Wallet address error: {str(e)}")

    async def test_get_user_orders(self):
        """Test get user orders - GET /api/trading/orders/my"""
        print("\nüìã Testing Get User Orders...")
        
        if not self.admin_token:
            print("‚ùå No admin token available")
            self.test_results.append({"endpoint": "GET /api/trading/orders/my", "status": "‚ùå FAIL", "details": "No admin token"})
            return
        
        try:
            headers = {"Authorization": f"Bearer {self.admin_token}"}
            response = await self.client.get(f"{BACKEND_URL}/trading/orders/my", headers=headers)
            
            if response.status_code == 200:
                data = response.json()
                orders_count = len(data) if isinstance(data, list) else 0
                
                print(f"‚úÖ Get user orders working")
                print(f"üìä User Orders: {orders_count}")
                
                # Verify user can see their orders
                if orders_count >= 0:  # Even 0 orders is valid
                    print("‚úÖ User can see their orders")
                    self.test_results.append({"endpoint": "GET /api/trading/orders/my", "status": "‚úÖ PASS", "details": f"User orders retrieval working ({orders_count} orders)"})
                else:
                    print("‚ùå Invalid orders response")
                    self.test_results.append({"endpoint": "GET /api/trading/orders/my", "status": "‚ùå FAIL", "details": "Invalid orders response"})
            else:
                print(f"‚ùå Get user orders failed: {response.status_code}")
                self.test_results.append({"endpoint": "GET /api/trading/orders/my", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                
        except Exception as e:
            print(f"‚ùå Get user orders error: {str(e)}")
            self.test_results.append({"endpoint": "GET /api/trading/orders/my", "status": "‚ùå ERROR", "details": str(e)})

    async def test_get_user_holdings(self):
        """Test get user holdings - GET /api/trading/holdings/my"""
        print("\nüíº Testing Get User Holdings...")
        
        if not self.admin_token:
            print("‚ùå No admin token available")
            self.test_results.append({"endpoint": "GET /api/trading/holdings/my", "status": "‚ùå FAIL", "details": "No admin token"})
            return
        
        try:
            headers = {"Authorization": f"Bearer {self.admin_token}"}
            response = await self.client.get(f"{BACKEND_URL}/trading/holdings/my", headers=headers)
            
            if response.status_code == 200:
                data = response.json()
                holdings_count = len(data) if isinstance(data, list) else 0
                
                print(f"‚úÖ Get user holdings working")
                print(f"üìä User Holdings: {holdings_count}")
                
                # Verify user can see their crypto holdings
                if holdings_count >= 0:  # Even 0 holdings is valid
                    print("‚úÖ User can see their crypto holdings")
                    self.test_results.append({"endpoint": "GET /api/trading/holdings/my", "status": "‚úÖ PASS", "details": f"User holdings retrieval working ({holdings_count} holdings)"})
                else:
                    print("‚ùå Invalid holdings response")
                    self.test_results.append({"endpoint": "GET /api/trading/holdings/my", "status": "‚ùå FAIL", "details": "Invalid holdings response"})
            else:
                print(f"‚ùå Get user holdings failed: {response.status_code}")
                self.test_results.append({"endpoint": "GET /api/trading/holdings/my", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                
        except Exception as e:
            print(f"‚ùå Get user holdings error: {str(e)}")
            self.test_results.append({"endpoint": "GET /api/trading/holdings/my", "status": "‚ùå ERROR", "details": str(e)})

    async def test_admin_get_all_users(self):
        """Test admin get all users - GET /api/admin/users"""
        print("\nüë• Testing Admin Get All Users...")
        
        if not self.admin_token:
            print("‚ùå No admin token available")
            self.test_results.append({"endpoint": "GET /api/admin/users", "status": "‚ùå FAIL", "details": "No admin token"})
            return
        
        try:
            headers = {"Authorization": f"Bearer {self.admin_token}"}
            response = await self.client.get(f"{BACKEND_URL}/admin/users", headers=headers)
            
            if response.status_code == 200:
                data = response.json()
                users_count = len(data) if isinstance(data, list) else 0
                
                print(f"‚úÖ Admin get all users working")
                print(f"üìä Total Users: {users_count}")
                
                # Verify admin can see all users
                if users_count > 0:
                    admin_users = [u for u in data if u.get('is_admin', False)]
                    regular_users = [u for u in data if not u.get('is_admin', False)]
                    
                    print(f"üìä Admin Users: {len(admin_users)}")
                    print(f"üìä Regular Users: {len(regular_users)}")
                    print("‚úÖ Admin can see all users")
                    
                    self.test_results.append({"endpoint": "GET /api/admin/users", "status": "‚úÖ PASS", "details": f"Admin can see all {users_count} users"})
                else:
                    print("‚ö†Ô∏è  No users found")
                    self.test_results.append({"endpoint": "GET /api/admin/users", "status": "‚ö†Ô∏è  PARTIAL", "details": "No users found"})
            else:
                print(f"‚ùå Admin get all users failed: {response.status_code}")
                self.test_results.append({"endpoint": "GET /api/admin/users", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                
        except Exception as e:
            print(f"‚ùå Admin get all users error: {str(e)}")
            self.test_results.append({"endpoint": "GET /api/admin/users", "status": "‚ùå ERROR", "details": str(e)})

    async def test_admin_get_all_orders(self):
        """Test admin get all orders - GET /api/admin/orders"""
        print("\nüìã Testing Admin Get All Orders...")
        
        if not self.admin_token:
            print("‚ùå No admin token available")
            self.test_results.append({"endpoint": "GET /api/admin/orders", "status": "‚ùå FAIL", "details": "No admin token"})
            return
        
        try:
            headers = {"Authorization": f"Bearer {self.admin_token}"}
            response = await self.client.get(f"{BACKEND_URL}/admin/orders", headers=headers)
            
            if response.status_code == 200:
                data = response.json()
                orders_count = len(data) if isinstance(data, list) else 0
                
                print(f"‚úÖ Admin get all orders working")
                print(f"üìä Total Orders: {orders_count}")
                
                # Verify admin can see all orders
                if orders_count > 0:
                    order_statuses = {}
                    for order in data:
                        status = order.get('status', 'unknown')
                        order_statuses[status] = order_statuses.get(status, 0) + 1
                    
                    print(f"üìä Order Statuses: {order_statuses}")
                    print("‚úÖ Admin can see all orders")
                    
                    self.test_results.append({"endpoint": "GET /api/admin/orders", "status": "‚úÖ PASS", "details": f"Admin can see all {orders_count} orders"})
                    return data
                else:
                    print("‚ö†Ô∏è  No orders found")
                    self.test_results.append({"endpoint": "GET /api/admin/orders", "status": "‚ö†Ô∏è  PARTIAL", "details": "No orders found"})
                    return []
            else:
                print(f"‚ùå Admin get all orders failed: {response.status_code}")
                self.test_results.append({"endpoint": "GET /api/admin/orders", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                return []
                
        except Exception as e:
            print(f"‚ùå Admin get all orders error: {str(e)}")
            self.test_results.append({"endpoint": "GET /api/admin/orders", "status": "‚ùå ERROR", "details": str(e)})
            return []

    async def test_admin_approve_order(self, orders_data):
        """Test admin approve order - POST /api/admin/orders/approve"""
        print("\n‚úÖ Testing Admin Order Approval...")
        
        if not self.admin_token:
            print("‚ùå No admin token available")
            self.test_results.append({"endpoint": "POST /api/admin/orders/approve", "status": "‚ùå FAIL", "details": "No admin token"})
            return
        
        try:
            # Find a pending order to approve
            pending_orders = [o for o in orders_data if o.get('status') == 'pending']
            
            if not pending_orders:
                print("‚ö†Ô∏è  No pending orders found for approval test")
                self.test_results.append({"endpoint": "POST /api/admin/orders/approve", "status": "‚ö†Ô∏è  SKIP", "details": "No pending orders to approve"})
                return
            
            order_to_approve = pending_orders[0]
            order_id = order_to_approve.get('id')
            
            headers = {"Authorization": f"Bearer {self.admin_token}"}
            approval_data = {
                "order_id": order_id,
                "action": "approve",
                "admin_note": "Test approval from comprehensive backend test"
            }
            
            response = await self.client.post(f"{BACKEND_URL}/admin/orders/approve", headers=headers, json=approval_data)
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Order approval working")
                print(f"üìä Order ID: {order_id[:8]}...")
                print(f"üìä Response: {data.get('message', 'N/A')}")
                
                # Verify order approval workflow
                print("‚úÖ Order approval workflow functional")
                self.test_results.append({"endpoint": "POST /api/admin/orders/approve", "status": "‚úÖ PASS", "details": "Order approval workflow working"})
            else:
                print(f"‚ùå Order approval failed: {response.status_code} - {response.text}")
                self.test_results.append({"endpoint": "POST /api/admin/orders/approve", "status": "‚ùå FAIL", "details": f"HTTP {response.status_code}"})
                
        except Exception as e:
            print(f"‚ùå Order approval error: {str(e)}")
            self.test_results.append({"endpoint": "POST /api/admin/orders/approve", "status": "‚ùå ERROR", "details": str(e)})

    async def test_status_codes_and_errors(self):
        """Test proper status codes and Persian error messages"""
        print("\nüõ°Ô∏è  Testing Status Codes and Error Handling...")
        
        error_tests = []
        
        # Test 401 Unauthorized
        try:
            response = await self.client.get(f"{BACKEND_URL}/admin/users")
            if response.status_code == 401:
                error_tests.append("‚úÖ 401 Unauthorized working")
            else:
                error_tests.append(f"‚ö†Ô∏è  Expected 401, got {response.status_code}")
        except:
            error_tests.append("‚ùå Error testing 401")
        
        # Test 403 Forbidden (if we had a regular user)
        # Test 404 Not Found
        try:
            response = await self.client.get(f"{BACKEND_URL}/nonexistent/endpoint")
            if response.status_code == 404:
                error_tests.append("‚úÖ 404 Not Found working")
            else:
                error_tests.append(f"‚ö†Ô∏è  Expected 404, got {response.status_code}")
        except:
            error_tests.append("‚ùå Error testing 404")
        
        # Test 422 Validation Error
        if self.admin_token:
            try:
                headers = {"Authorization": f"Bearer {self.admin_token}"}
                response = await self.client.post(f"{BACKEND_URL}/trading/order", headers=headers, json={"invalid": "data"})
                if response.status_code == 422:
                    error_tests.append("‚úÖ 422 Validation Error working")
                else:
                    error_tests.append(f"‚ö†Ô∏è  Expected 422, got {response.status_code}")
            except:
                error_tests.append("‚ùå Error testing 422")
        
        # Test Persian error messages
        if self.admin_token:
            try:
                headers = {"Authorization": f"Bearer {self.admin_token}"}
                # Try to create order with insufficient balance (if possible)
                response = await self.client.post(f"{BACKEND_URL}/trading/order", headers=headers, json={
                    "order_type": "buy",
                    "coin_symbol": "BTC",
                    "coin_id": "bitcoin",
                    "amount_tmn": 999999999999  # Very large amount
                })
                
                if response.status_code in [400, 422]:
                    response_text = response.text
                    if any(char in response_text for char in 'ÿßÿ®Ÿæÿ™ÿ´ÿ¨⁄Üÿ≠ÿÆÿØÿ∞ÿ±ÿ≤⁄òÿ≥ÿ¥ÿµÿ∂ÿ∑ÿ∏ÿπÿ∫ŸÅŸÇ⁄©⁄ØŸÑŸÖŸÜŸàŸá€å'):
                        error_tests.append("‚úÖ Persian error messages working")
                    else:
                        error_tests.append("‚ö†Ô∏è  Error messages not in Persian")
                else:
                    error_tests.append("‚ö†Ô∏è  Could not test Persian error messages")
            except:
                error_tests.append("‚ùå Error testing Persian messages")
        
        print("\n".join(error_tests))
        
        passed_error_tests = len([t for t in error_tests if "‚úÖ" in t])
        total_error_tests = len(error_tests)
        
        if passed_error_tests >= total_error_tests * 0.75:  # 75% pass rate
            self.test_results.append({"endpoint": "Error Handling", "status": "‚úÖ PASS", "details": f"{passed_error_tests}/{total_error_tests} error handling tests passed"})
        else:
            self.test_results.append({"endpoint": "Error Handling", "status": "‚ö†Ô∏è  PARTIAL", "details": f"{passed_error_tests}/{total_error_tests} error handling tests passed"})

    async def run_all_tests(self):
        """Run all tests as specified in the review request"""
        print("üöÄ COMPREHENSIVE BACKEND TESTING - REVIEW REQUEST")
        print("=" * 80)
        print("Testing ALL critical backend functionality for Iranian Crypto Exchange")
        print("=" * 80)
        
        # Test all endpoints in order
        if not await self.test_admin_login():
            print("‚ùå Cannot proceed without admin authentication")
            return
        
        await self.test_user_registration()
        await self.test_get_current_user()
        await self.test_crypto_prices()
        await self.test_create_buy_order()
        await self.test_get_user_orders()
        await self.test_get_user_holdings()
        await self.test_admin_get_all_users()
        
        # Get orders data for approval test
        orders_data = await self.test_admin_get_all_orders()
        await self.test_admin_approve_order(orders_data)
        
        await self.test_status_codes_and_errors()
        
        # Print comprehensive summary
        print("\n" + "=" * 80)
        print("üìã FINAL COMPREHENSIVE BACKEND TEST RESULTS")
        print("=" * 80)
        
        passed_tests = [r for r in self.test_results if "‚úÖ PASS" in r["status"]]
        failed_tests = [r for r in self.test_results if "‚ùå" in r["status"]]
        warning_tests = [r for r in self.test_results if "‚ö†Ô∏è" in r["status"]]
        
        print(f"‚úÖ PASSED: {len(passed_tests)}")
        print(f"‚ùå FAILED: {len(failed_tests)}")
        print(f"‚ö†Ô∏è  WARNINGS/PARTIAL: {len(warning_tests)}")
        print(f"üìä TOTAL TESTS: {len(self.test_results)}")
        
        success_rate = (len(passed_tests) / len(self.test_results)) * 100 if self.test_results else 0
        print(f"üéØ SUCCESS RATE: {success_rate:.1f}%")
        
        print("\nüìã DETAILED RESULTS:")
        for result in self.test_results:
            print(f"  {result['status']} {result['endpoint']}: {result['details']}")
        
        if failed_tests:
            print(f"\n‚ùå CRITICAL ISSUES ({len(failed_tests)}):")
            for test in failed_tests:
                print(f"  - {test['endpoint']}: {test['details']}")
        
        if warning_tests:
            print(f"\n‚ö†Ô∏è  WARNINGS/PARTIAL ({len(warning_tests)}):")
            for test in warning_tests:
                print(f"  - {test['endpoint']}: {test['details']}")
        
        print("\nüéØ REVIEW REQUEST COMPLIANCE:")
        
        # Authentication & User Management
        auth_endpoints = ["POST /api/auth/register", "POST /api/auth/login", "GET /api/auth/me"]
        auth_results = [r for r in self.test_results if r['endpoint'] in auth_endpoints]
        auth_passed = len([r for r in auth_results if "‚úÖ PASS" in r['status']])
        print(f"üîê Authentication & User Management: {auth_passed}/{len(auth_results)} ({'‚úÖ PASS' if auth_passed == len(auth_results) else '‚ö†Ô∏è  ISSUES'})")
        
        # Trading System
        trading_endpoints = ["GET /api/crypto/prices", "POST /api/trading/order", "GET /api/trading/orders/my", "GET /api/trading/holdings/my"]
        trading_results = [r for r in self.test_results if r['endpoint'] in trading_endpoints]
        trading_passed = len([r for r in trading_results if "‚úÖ PASS" in r['status']])
        print(f"üí∞ Trading System: {trading_passed}/{len(trading_results)} ({'‚úÖ PASS' if trading_passed == len(trading_results) else '‚ö†Ô∏è  ISSUES'})")
        
        # Admin Functions
        admin_endpoints = ["GET /api/admin/users", "GET /api/admin/orders", "POST /api/admin/orders/approve"]
        admin_results = [r for r in self.test_results if r['endpoint'] in admin_endpoints]
        admin_passed = len([r for r in admin_results if "‚úÖ PASS" in r['status']])
        print(f"üëë Admin Functions: {admin_passed}/{len(admin_results)} ({'‚úÖ PASS' if admin_passed == len(admin_results) else '‚ö†Ô∏è  ISSUES'})")
        
        # Overall assessment
        if success_rate >= 90:
            print("\nüü¢ OVERALL ASSESSMENT: EXCELLENT")
            print("   All critical backend functionality working correctly")
            print("   System ready for production use")
        elif success_rate >= 75:
            print("\nüü° OVERALL ASSESSMENT: GOOD")
            print("   Most functionality working, minor issues present")
            print("   System mostly ready for production")
        elif success_rate >= 50:
            print("\nüü† OVERALL ASSESSMENT: FAIR")
            print("   Some critical issues need attention")
            print("   System needs fixes before production")
        else:
            print("\nüî¥ OVERALL ASSESSMENT: POOR")
            print("   Major issues require immediate attention")
            print("   System not ready for production")
        
        await self.client.aclose()

async def main():
    """Main test execution"""
    tester = FinalBackendTester()
    await tester.run_all_tests()

if __name__ == "__main__":
    asyncio.run(main())